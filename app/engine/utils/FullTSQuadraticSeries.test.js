'use strict'
/*
  Open Rowing Monitor, https://github.com/JaapvanEkris/openrowingmonitor

  This tests the Quadratic Theil-Senn Regression algorithm. As regression is an estimation and methods have biasses,
  we need to accept some slack with respect to real-life examples
*/
import { test } from 'uvu'
import * as assert from 'uvu/assert'

import { createTSQuadraticSeries } from './FullTSQuadraticSeries.js'

test('Quadratic Approximation startup behaviour', () => {
  const dataSeries = createTSQuadraticSeries(10)
  testCoefficientA(dataSeries, 0)
  testCoefficientB(dataSeries, 0)
  testCoefficientC(dataSeries, 0)
  dataSeries.push(-1, 2)
  testCoefficientA(dataSeries, 0)
  testCoefficientB(dataSeries, 0)
  testCoefficientC(dataSeries, 0)
  dataSeries.push(0, 2)
  testCoefficientA(dataSeries, 0)
  testCoefficientB(dataSeries, 0)
  testCoefficientC(dataSeries, 0)
  dataSeries.push(1, 6)
  testCoefficientA(dataSeries, 2)
  testCoefficientB(dataSeries, 2)
  testCoefficientC(dataSeries, 2)
})

test('Quadratic Approximation on a perfect noisefree function y = 2 * Math.pow(x, 2) + 2 * x + 2, 21 datapoints', () => {
  // Data based on 2 x^2 + 2 x + 2
  const dataSeries = createTSQuadraticSeries(21)
  dataSeries.push(-10, 182)
  dataSeries.push(-9, 146)
  dataSeries.push(-8, 114)
  dataSeries.push(-7, 86)
  dataSeries.push(-6, 62)
  dataSeries.push(-5, 42)
  dataSeries.push(-4, 26)
  dataSeries.push(-3, 14) // Pi ;)
  dataSeries.push(-2, 6)
  dataSeries.push(-1, 2)
  dataSeries.push(0, 2)
  dataSeries.push(1, 6)
  dataSeries.push(2, 14)
  dataSeries.push(3, 26)
  dataSeries.push(4, 42)
  dataSeries.push(5, 62)
  dataSeries.push(6, 86)
  dataSeries.push(7, 114)
  dataSeries.push(8, 146)
  dataSeries.push(9, 182)
  dataSeries.push(10, 222)
  testCoefficientA(dataSeries, 2)
  testCoefficientB(dataSeries, 2)
  testCoefficientC(dataSeries, 2)
  testGoodnessOfFitEquals(dataSeries, 1)
})

test('Quadratic Approximation on a perfect noisefree function y = 2 * Math.pow(x, 2) + 2 * x + 2, with 10 datapoints and some shifting in the series', () => {
  // Data based on 2 x^2 + 2 x + 2, split the dataset in two to see its behaviour when it is around the Vertex
  const dataSeries = createTSQuadraticSeries(10)
  dataSeries.push(-10, 182)
  dataSeries.push(-9, 146)
  dataSeries.push(-8, 114)
  dataSeries.push(-7, 86)
  dataSeries.push(-6, 62)
  dataSeries.push(-5, 42)
  dataSeries.push(-4, 26)
  dataSeries.push(-3, 14) // Pi ;)
  dataSeries.push(-2, 6)
  dataSeries.push(-1, 2)
  dataSeries.push(0, 2)
  testCoefficientA(dataSeries, 2)
  testCoefficientB(dataSeries, 2)
  testCoefficientC(dataSeries, 2)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(1, 6)
  dataSeries.push(2, 14)
  dataSeries.push(3, 26)
  dataSeries.push(4, 42)
  dataSeries.push(5, 62)
  dataSeries.push(6, 86)
  dataSeries.push(7, 114)
  dataSeries.push(8, 146)
  dataSeries.push(9, 182)
  dataSeries.push(10, 222)
  testCoefficientA(dataSeries, 2)
  testCoefficientB(dataSeries, 2)
  testCoefficientC(dataSeries, 2)
  testGoodnessOfFitEquals(dataSeries, 1)
})

test('Quadratic Approximation on function y = 4 * Math.pow(x, 2) + 4 * x + 4, noisefree', () => {
  // Data based on 4 x^2 + 4 x + 4
  const dataSeries = createTSQuadraticSeries(11)
  dataSeries.push(-11, 444)
  dataSeries.push(-10, 364)
  dataSeries.push(-9, 292)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(-8, 228)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(-7, 172)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(-6, 124)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(-5, 84)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(-4, 52)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(-3, 28)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(-2, 12)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(-1, 4)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(0, 4)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(1, 12)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(2, 28)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(3, 52)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(4, 84)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(5, 124)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(6, 172)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(7, 228)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(8, 292)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(9, 364)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(10, 444)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 1)
})

test('Quadratic Approximation on function y = 4 * Math.pow(x, 2) + 4 * x + 4, with some noise (+/- 1)', () => {
  // Data based on 4 x^2 + 4 x + 4
  const dataSeries = createTSQuadraticSeries(11)
  dataSeries.push(-11, 443)
  dataSeries.push(-10, 365)
  dataSeries.push(-9, 291)
  testCoefficientA(dataSeries, 2)
  testCoefficientB(dataSeries, -36)
  testCoefficientC(dataSeries, -195)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(-8, 229)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4.333333333333334)
  testCoefficientC(dataSeries, 7.166666666666671)
  testGoodnessOfFitEquals(dataSeries, 0.9998746217034155)
  dataSeries.push(-7, 171)
  testCoefficientA(dataSeries, 3.3333333333333335)
  testCoefficientB(dataSeries, -7.999999999999991)
  testCoefficientC(dataSeries, -48.33333333333328)
  testGoodnessOfFitEquals(dataSeries, 0.9998468647471163)
  dataSeries.push(-6, 125)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 0.9999165499911914)
  dataSeries.push(-5, 83)
  testCoefficientA(dataSeries, 3.8666666666666667)
  testCoefficientB(dataSeries, 1.8666666666666671)
  testCoefficientC(dataSeries, -4.333333333333336) // This is quite acceptable as ORM ignores the C
  testGoodnessOfFitEquals(dataSeries, 0.9999366117119067)
  dataSeries.push(-4, 53)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 0.9999402806808002)
  dataSeries.push(-3, 27)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 3)
  testGoodnessOfFitEquals(dataSeries, 0.9999042318865254)
  dataSeries.push(-2, 13)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 0.9999495097395712)
  dataSeries.push(-1, 3)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 3)
  testGoodnessOfFitEquals(dataSeries, 0.9999117149452151)
  dataSeries.push(0, 5)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 5)
  testGoodnessOfFitEquals(dataSeries, 0.9998721709098177)
  dataSeries.push(1, 11)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 3)
  testGoodnessOfFitEquals(dataSeries, 0.9997996371611135)
  dataSeries.push(2, 29)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 5)
  testGoodnessOfFitEquals(dataSeries, 0.9996545703483187)
  dataSeries.push(3, 51)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 3)
  testGoodnessOfFitEquals(dataSeries, 0.9993201651380683)
  dataSeries.push(4, 85)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 5)
  testGoodnessOfFitEquals(dataSeries, 0.9987227718173796)
  dataSeries.push(5, 123)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 3)
  testGoodnessOfFitEquals(dataSeries, 0.9986961263098004)
  dataSeries.push(6, 173)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 5)
  testGoodnessOfFitEquals(dataSeries, 0.9993274803746546)
  dataSeries.push(7, 227)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 3)
  testGoodnessOfFitEquals(dataSeries, 0.9996526505917571)
  dataSeries.push(8, 293)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 5)
  testGoodnessOfFitEquals(dataSeries, 0.9998002774328024)
  dataSeries.push(9, 363)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 3) // We get a 3 instead of 4, which is quite acceptable (especially since ORM ignores the C)
  testGoodnessOfFitEquals(dataSeries, 0.9998719089295779)
  dataSeries.push(10, 444)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 0.9999558104799866)
})

test('Quadratic Approximation on function y = 4 * Math.pow(x, 2) + 4 * x + 4, with some noise (+/- 1) and spikes (+/- 9)', () => {
  // Data based on 4 x^2 + 4 x + 4
  const dataSeries = createTSQuadraticSeries(11)
  dataSeries.push(-11, 443)
  dataSeries.push(-10, 365)
  dataSeries.push(-9, 291)
  dataSeries.push(-8, 229)
  dataSeries.push(-7, 171)
  dataSeries.push(-6, 125)
  dataSeries.push(-5, 83)
  dataSeries.push(-4, 53)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 0.9999402806808002)
  dataSeries.push(-3, 37) // FIRST SPIKE +9
  testCoefficientA(dataSeries, 4.215277777777778)
  testCoefficientB(dataSeries, 7.694940476190471)
  testCoefficientC(dataSeries, 18.816964285714235)
  testGoodnessOfFitEquals(dataSeries, 0.9997971509015441)
  dataSeries.push(-2, 3) // SECOND SPIKE -9
  testCoefficientA(dataSeries, 3.9714285714285715)
  testCoefficientB(dataSeries, 3.6000000000000036) // Coefficient B seems to take a hit anyway
  testCoefficientC(dataSeries, 2.842857142857163) // We get a 2.8 instead of 4, which is quite acceptable (especially since ORM ignores the C)
  testGoodnessOfFitEquals(dataSeries, 0.9991656951087963)
  dataSeries.push(-1, 3)
  testCoefficientA(dataSeries, 3.9555555555555557)
  testCoefficientB(dataSeries, 3.37777777777778)
  testCoefficientC(dataSeries, 2.4222222222222243)
  testGoodnessOfFitEquals(dataSeries, 0.9992769580376006)
  dataSeries.push(0, 5)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 5)
  testGoodnessOfFitEquals(dataSeries, 0.9988530568930122)
  dataSeries.push(1, 11)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 3)
  testGoodnessOfFitEquals(dataSeries, 0.9982053643291688)
  dataSeries.push(2, 29)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 5)
  testGoodnessOfFitEquals(dataSeries, 0.9969166946967148)
  dataSeries.push(3, 51)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 3)
  testGoodnessOfFitEquals(dataSeries, 0.9939797134586851)
  dataSeries.push(4, 85)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 5)
  testGoodnessOfFitEquals(dataSeries, 0.9888468297958631)
  dataSeries.push(5, 123)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 3)
  testGoodnessOfFitEquals(dataSeries, 0.9886212128178015)
  dataSeries.push(6, 173)
  testCoefficientA(dataSeries, 4.044444444444444)
  testCoefficientB(dataSeries, 3.822222222222223)
  testCoefficientC(dataSeries, 3.577777777777783)
  testGoodnessOfFitEquals(dataSeries, 0.9945681627011398)
  dataSeries.push(7, 227)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 3)
  testGoodnessOfFitEquals(dataSeries, 0.9968997006175546)
  dataSeries.push(8, 293)
  testCoefficientA(dataSeries, 3.9047619047619047)
  testCoefficientB(dataSeries, 4.888888888888889)
  testCoefficientC(dataSeries, 2.9682539682539684) // This is quite acceptable as ORM ignores the C
  testGoodnessOfFitEquals(dataSeries, 0.9995034675221599)
  dataSeries.push(9, 363)
  testCoefficientA(dataSeries, 4) // These results match up 100% with the previous test, showing that a spike has no carry over effects
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 3)
  testGoodnessOfFitEquals(dataSeries, 0.9998719089295779)
  dataSeries.push(10, 444)
  testCoefficientA(dataSeries, 4)
  testCoefficientB(dataSeries, 4)
  testCoefficientC(dataSeries, 4)
  testGoodnessOfFitEquals(dataSeries, 0.9999558104799866)
})

test('Quadratic TS Estimation should be decent for standard real-life example from MathBits with some noise', () => {
  // Data based on https://mathbits.com/MathBits/TISection/Statistics2/quadratic.html
  const dataSeries = createTSQuadraticSeries(13)
  dataSeries.push(10, 115.6)
  dataSeries.push(15, 157.2)
  dataSeries.push(20, 189.2)
  dataSeries.push(24, 220.8)
  dataSeries.push(30, 253.8)
  dataSeries.push(34, 269.2)
  dataSeries.push(40, 284.8)
  dataSeries.push(45, 285.0)
  dataSeries.push(48, 277.4)
  dataSeries.push(50, 269.2)
  dataSeries.push(58, 244.2)
  dataSeries.push(60, 231.4)
  dataSeries.push(64, 180.4)
  testCoefficientA(dataSeries, -0.17702838827838824) // In the example, the TI084 results in -0.1737141137, which we consider acceptably close
  testCoefficientB(dataSeries, 14.929144536019532) // In the example, the TI084 results in 14.52117133, which we consider acceptably close
  testCoefficientC(dataSeries, -31.325531135531037) // In the example, the TI084 results in -21.89774466, which we consider acceptably close
  testGoodnessOfFitEquals(dataSeries, 0.9781087883163964)
})

test('Quadratic TS Estimation should be decent for standard real-life example from VarsityTutors with some noise', () => {
  // Test based on https://www.varsitytutors.com/hotmath/hotmath_help/topics/quadratic-regression
  const dataSeries = createTSQuadraticSeries(7)
  dataSeries.push(-3, 7.5)
  dataSeries.push(-2, 3)
  dataSeries.push(-1, 0.5)
  dataSeries.push(0, 1)
  dataSeries.push(1, 3)
  dataSeries.push(2, 6)
  dataSeries.push(3, 14)
  testCoefficientA(dataSeries, 1.0833333333333333) // The example results in 1.1071 for OLS, which we consider acceptably close
  testCoefficientB(dataSeries, 1.0833333333333333) // The example results in 1 for OLS, which we consider acceptably close
  testCoefficientC(dataSeries, 0.8333333333333335) // The example results in 0.5714 for OLS, which we consider acceptably close
  testGoodnessOfFitEquals(dataSeries, 0.9851153039832286)
})

test('Quadratic TS Estimation should be decent for standard example from VTUPulse with some noise, without the vertex being part of the dataset', () => {
  // Test based on https://www.vtupulse.com/machine-learning/quadratic-polynomial-regression-model-solved-example/
  const dataSeries = createTSQuadraticSeries(5)
  dataSeries.push(3, 2.5)
  dataSeries.push(4, 3.3)
  dataSeries.push(5, 3.8)
  dataSeries.push(6, 6.5)
  dataSeries.push(7, 11.5)
  testCoefficientA(dataSeries, 0.8583333333333334) // The example results in 0.7642857 for OLS, which we consider acceptably close given the small sample size
  testCoefficientB(dataSeries, -6.420833333333334) // The example results in -5.5128571 for OLS, which we consider acceptably close given the small sample size
  testCoefficientC(dataSeries, 14.387500000000003) // The example results in 12.4285714 for OLS, which we consider acceptably close given the small sample size
  testGoodnessOfFitEquals(dataSeries, 0.9825283785404673)
})

test('Quadratic TS Estimation should be decent for standard real-life example from Uni Berlin with some noise without the vertex being part of the dataset', () => {
  // Test based on https://www.geo.fu-berlin.de/en/v/soga/Basics-of-statistics/Linear-Regression/Polynomial-Regression/Polynomial-Regression---An-example/index.html
  const dataSeries = createTSQuadraticSeries(25)
  dataSeries.push(0.001399613, -0.23436656)
  dataSeries.push(0.971629779, 0.64689524)
  dataSeries.push(0.579119475, -0.92635765)
  dataSeries.push(0.335693937, 0.13000706)
  dataSeries.push(0.736736086, -0.89294863)
  dataSeries.push(0.492572335, 0.33854780)
  dataSeries.push(0.737133774, -1.24171910)
  dataSeries.push(0.563693769, -0.22523318)
  dataSeries.push(0.877603280, -0.12962722)
  dataSeries.push(0.141426545, 0.37632006)
  dataSeries.push(0.307203910, 0.30299077)
  dataSeries.push(0.024509308, -0.21162739)
  dataSeries.push(0.843665029, -0.76468719)
  dataSeries.push(0.771206067, -0.90455412)
  dataSeries.push(0.149670258, 0.77097952)
  dataSeries.push(0.359605608, 0.56466366)
  dataSeries.push(0.049612895, 0.18897607)
  dataSeries.push(0.409898906, 0.32531750)
  dataSeries.push(0.935457898, -0.78703491)
  dataSeries.push(0.149476207, 0.80585375)
  dataSeries.push(0.234315216, 0.62944986)
  dataSeries.push(0.455297119, 0.02353327)
  dataSeries.push(0.102696671, 0.27621694)
  dataSeries.push(0.715372314, -1.20379729)
  dataSeries.push(0.681745393, -0.83059624)
  testCoefficientA(dataSeries, -2.030477132951317)
  testCoefficientB(dataSeries, 0.5976858995201227)
  testCoefficientC(dataSeries, 0.17630021024409503)
  testGoodnessOfFitEquals(dataSeries, 0.23921110548689295)
})

test('Quadratic TS Estimation should be decent for standard real-life example from Statology.org with some noise and chaotic X values', () => {
  // Test based on https://www.statology.org/quadratic-regression-r/
  const dataSeries = createTSQuadraticSeries(11)
  dataSeries.push(6, 14)
  dataSeries.push(9, 28)
  dataSeries.push(12, 50)
  dataSeries.push(14, 70)
  dataSeries.push(30, 89)
  dataSeries.push(35, 94)
  dataSeries.push(40, 90)
  dataSeries.push(47, 75)
  dataSeries.push(51, 59)
  dataSeries.push(55, 44)
  dataSeries.push(60, 27)
  testCoefficientA(dataSeries, -0.10119047619047619) // The example results in -0.1012 for R after two rounds, which we consider acceptably close
  testCoefficientB(dataSeries, 6.801190476190477) // The example results in 6.7444 for R after two rounds, which we consider acceptably close
  testCoefficientC(dataSeries, -21.126190476190516) // The example results in 18.2536 for R after two rounds, but for ORM, this factor is irrelevant
  testGoodnessOfFitEquals(dataSeries, 0.9571127392718894)
})

test('Quadratic TS Estimation should be decent for standard real-life example from StatsDirect.com with some noise and chaotic X values', () => {
  // Test based on https://www.statsdirect.com/help/regression_and_correlation/polynomial.htm
  const dataSeries = createTSQuadraticSeries(10)
  dataSeries.push(1290, 1182)
  dataSeries.push(1350, 1172)
  dataSeries.push(1470, 1264)
  dataSeries.push(1600, 1493)
  dataSeries.push(1710, 1571)
  dataSeries.push(1840, 1711)
  dataSeries.push(1980, 1804)
  dataSeries.push(2230, 1840)
  dataSeries.push(2400, 1956)
  dataSeries.push(2930, 1954)
  testCoefficientA(dataSeries, -0.00046251263566907585) // The example results in -0.00045 through QR decomposition by Givens rotations, which we consider acceptably close
  testCoefficientB(dataSeries, 2.441798780934297) // The example results in 2.39893 for QR decomposition by Givens rotations, which we consider acceptably close
  testCoefficientC(dataSeries, -1235.044997485239) // The example results in -1216.143887 for QR decomposition by Givens rotations, but for ORM, this factor is irrelevant
  testGoodnessOfFitEquals(dataSeries, 0.9790379024208455)
})

test('Quadratic Approximation with a clean function and a reset', () => {
  // Data based on 2 x^2 + 2 x + 2
  const dataSeries = createTSQuadraticSeries(10)
  dataSeries.push(-10, 182)
  dataSeries.push(-9, 146)
  dataSeries.push(-8, 114)
  dataSeries.push(-7, 86)
  dataSeries.push(-6, 62)
  dataSeries.push(-5, 42)
  testCoefficientA(dataSeries, 2)
  testCoefficientB(dataSeries, 2)
  testCoefficientC(dataSeries, 2)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(-4, 26)
  dataSeries.push(-3, 14) // Pi ;)
  dataSeries.push(-2, 6)
  dataSeries.push(-1, 2)
  dataSeries.push(0, 2)
  dataSeries.push(1, 6)
  dataSeries.push(2, 14)
  testCoefficientA(dataSeries, 2)
  testCoefficientB(dataSeries, 2)
  testCoefficientC(dataSeries, 2)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.push(3, 26)
  dataSeries.push(4, 42)
  dataSeries.push(5, 62)
  dataSeries.push(6, 86)
  dataSeries.push(7, 114)
  dataSeries.push(8, 146)
  dataSeries.push(9, 182)
  dataSeries.push(10, 222)
  testCoefficientA(dataSeries, 2)
  testCoefficientB(dataSeries, 2)
  testCoefficientC(dataSeries, 2)
  testGoodnessOfFitEquals(dataSeries, 1)
  dataSeries.reset()
  testCoefficientA(dataSeries, 0)
  testCoefficientB(dataSeries, 0)
  testCoefficientC(dataSeries, 0)
  testGoodnessOfFitEquals(dataSeries, 0)
  dataSeries.push(-1, 2)
  testCoefficientA(dataSeries, 0)
  testCoefficientB(dataSeries, 0)
  testCoefficientC(dataSeries, 0)
  testGoodnessOfFitEquals(dataSeries, 0)
  dataSeries.push(0, 2)
  testCoefficientA(dataSeries, 0)
  testCoefficientB(dataSeries, 0)
  testCoefficientC(dataSeries, 0)
  testGoodnessOfFitEquals(dataSeries, 0)
  dataSeries.push(1, 6)
  testCoefficientA(dataSeries, 2)
  testCoefficientB(dataSeries, 2)
  testCoefficientC(dataSeries, 2)
  testGoodnessOfFitEquals(dataSeries, 1)
})

test('Quadratic TS Estimation should result in a straight line for function y = x', () => {
  // As ORM will encounter straight lines (when forces are balanced on the flywheel, there is no acceleration/deceleration), so we need to test this as well
  const dataSeries = createTSQuadraticSeries(7)
  dataSeries.push(0, 0)
  dataSeries.push(1, 1)
  dataSeries.push(2, 2)
  dataSeries.push(3, 3)
  dataSeries.push(4, 4)
  dataSeries.push(5, 5)
  dataSeries.push(6, 6)
  testCoefficientA(dataSeries, 0)
  testCoefficientB(dataSeries, 1)
  testCoefficientC(dataSeries, 0)
  testGoodnessOfFitEquals(dataSeries, 1)
})

function testCoefficientA (series, expectedValue) {
  assert.ok(series.coefficientA() === expectedValue, `Expected value for coefficientA at X-position ${series.xAtSeriesEnd()} is ${expectedValue}, encountered a ${series.coefficientA()}`)
}

function testCoefficientB (series, expectedValue) {
  assert.ok(series.coefficientB() === expectedValue, `Expected value for coefficientB at X-position ${series.xAtSeriesEnd()} is ${expectedValue}, encountered a ${series.coefficientB()}`)
}

function testCoefficientC (series, expectedValue) {
  assert.ok(series.coefficientC() === expectedValue, `Expected value for coefficientC at X-position ${series.xAtSeriesEnd()} is ${expectedValue}, encountered a ${series.coefficientC()}`)
}

function testGoodnessOfFitEquals (series, expectedValue) {
  assert.ok(series.goodnessOfFit() === expectedValue, `Expected goodnessOfFit at X-position ${series.xAtSeriesEnd()} is ${expectedValue}, encountered ${series.goodnessOfFit()}`)
}

function testGoodnessOfFitBetween (series, expectedValueAbove, expectedValueBelow) { // eslint-disable-line no-unused-vars
  assert.ok(series.goodnessOfFit() > expectedValueAbove, `Expected goodnessOfFit at X-position ${series.xAtSeriesEnd()} above ${expectedValueAbove}, encountered ${series.goodnessOfFit()}`)
  assert.ok(series.goodnessOfFit() < expectedValueBelow, `Expected goodnessOfFit at X-position ${series.xAtSeriesEnd()} below ${expectedValueBelow}, encountered ${series.goodnessOfFit()}`)
}

function testSlope (series, position, expectedValue) { // eslint-disable-line no-unused-vars
  assert.ok(series.slope(position) === expectedValue, `Expected value for Slope-${position} at X-position ${series.xAtSeriesEnd()} (slope at X-position ${series.xAtPosition(position)}) is ${expectedValue}, encountered a ${series.slope(position)}`)
}

function reportAll (series) { // eslint-disable-line no-unused-vars
  assert.ok(series.coefficientA() === 99, `time: ${series.xAtSeriesEnd()}, coefficientA: ${series.coefficientA()}, coefficientB: ${series.coefficientB()}, coefficientC: ${series.coefficientC()}, Slope-10: ${series.slope(10)}, Slope-9: ${series.slope(9)}, Slope-8: ${series.slope(8)}, Slope-7: ${series.slope(7)}, Slope-6: ${series.slope(6)}, Slope-5: ${series.slope(5)}, Slope-4: ${series.slope(4)}, Slope-3: ${series.slope(3)}, Slope-2: ${series.slope(2)}, Slope-1: ${series.slope(1)}, Slope-0: ${series.slope(0)}`)
}

test.run()
